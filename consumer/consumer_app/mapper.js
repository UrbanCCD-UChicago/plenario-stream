var promise = require('promise');
var util = require('util');
var request = require('request');
var logger = require('./util/logger');

var log = logger().getLogger('mapper');

/**
 * pulls from postgres to create most up-to-date mapping of sensor names to array of properties
 *
 * @param {pg.Pool} pg_pool = postgres client pool
 * @return {promise} yields map on fulfillment
 * in format:
 * { TMP112: { 'Temperature':'temperature.temperature' },
 * BMP340: { 'Temp':'temperature.temperature', 'relative humidity':'humidity.humidity' },
 * UBQ120: { 'x':'magneticField.X', 'y':'magneticField.Y', 'z':'magneticField.Z' },
 * PRE450: { 'Atm Pressure':'atmosphericPressure.pressure' } }
 * where each key is the expected key from the node and each value is the equivalent FoI.property
 */
var update_map = function (pg_pool) {
    log.info('in update_map');
    var p = new promise(function (fulfill, reject) {
        pg_pool.connect(function (err, client, done) {
            if (err) {
                reject('error connecting client in update_map ', err);
            }
            client.query('SELECT * FROM sensor__sensors', function (err, result) {
                done();
                if (err) {
                    reject('error running query in update_map ', err);
                }
                var map = {};
                for (var i = 0; i < result.rows.length; i++) {
                    map[result.rows[i].name] = result.rows[i].observed_properties;
                }
                fulfill(map);
            });
        });
    });
    return p
};

/**
 * takes in a sensor reading, inserts it into redshift, and emits it to the socket server
 *
 * @param {Object} obs = observation
 * in format:
 * { "node_id": "00A",
 *  "node_config": "011ab78",
 *  "datetime": "2016-08-05T00:00:08.246000",
 *  "sensor": "HTU21D",
 *  "data": { temperature: 37.90,
 *            humidity: 27.48 } }
 * @param {Object} map = sensor name to property array mapping as generated by update_map
 * @param {pg.Pool} pg_pool
 * @param {pg.Pool} rs_pool
 * @param {socket} socket = socket.io client sending data to socket server app
 * @param {Array} blacklist = array of all sensor names whose metadata appears to be incorrect
 * @return {boolean} true if map needs to be updated, false otherwise
 */
var parse_insert_emit = function (obs, map, pg_pool, rs_pool, socket, blacklist) {
    log.info('in parse_insert_emit');
    // pulls postgres immediately if sensor is not known or properties are not reported as expected
    if (!(obs.sensor in map) || (obs.sensor in map && invalid_keys(obs, map).length > 0)) {
        log.info('bad map');
        update_map(pg_pool).then(function (new_map) {
            log.info('new map received');
            log.info(new_map);
            if (!(obs.sensor in new_map)) {
                log.info('sensor not in new map');
                // this means we don't have the mapping for a sensor and it's not in postgres
                // send message to apiary if message not already sent
                send_error(obs.sensor, blacklist, 'does_not_exist', null);
                // banish observation to the 'Island of Misfit Values'
                redshift_insert(obs, new_map, rs_pool, true);
                return true
            }
            else if (invalid_keys(obs, new_map).length > 0) {
                log.info('invalid keys in new map');
                // this means there is an unknown or faulty key being sent from beehive
                // send message to apiary if message not already sent
                send_error(obs.sensor, blacklist, 'invalid_key', invalid_keys(obs, new_map));
                // banish observation to the 'Island of Misfit Values', the unknownfeature table
                redshift_insert(obs, new_map, rs_pool, true);
                return true
            }
            else {
                log.info('new map fixed everything');
                // updating the map fixed the discrepancy
                // send delete message if sensor in blacklist
                send_correct(obs.sensor, blacklist);
                redshift_insert(obs, new_map, rs_pool, false);
                var obs_list = format_obs(obs, new_map);
                for (var i = 0; i < obs_list.length; i++) {
                    socket.emit('internal_data', obs_list[i]);
                }
                return true
            }
        }, function (err) {
            log.error(err)
        })
    }
    else {
        // checks show that the mapping will work to input values into the database - go for it
        redshift_insert(obs, map, rs_pool, false);
        var obs_list = format_obs(obs, map);
        for (var i = 0; i < obs_list.length; i++){
            socket.emit('internal_data', obs_list[i]);
        }
        return false
    }
};

/**
 * inserts observation into redshift
 *
 * @param {Object} obs = observation
 * in format:
 * { "node_id": "00A",
 *  "node_config": "011ab78",
 *  "datetime": "2016-08-05T00:00:08.246000",
 *  "sensor": "HTU21D",
 *  "data": { temperature: 37.90,
 *            humidity: 27.48 } }
 * @param {Object} map = sensor name to property array mapping as generated by update_map
 * @param {pg.Pool} rs_pool
 * @param {boolean} misfit = true if FoI table cannot be found then value array must be stored as a string
 * in the 'unknownfeature' table (AKA the 'Island of Misfit Values')
 */
function redshift_insert(obs, map, rs_pool, misfit) {
    log.info('in redshift_insert');
    // works off (node_id, datetime, sensor, {values}, procedures) database model for now
    // if node_config format is accepted, change this
    rs_pool.connect(function (err, rs_client, done) {
        if (err) {
            log.error('error connecting client in redshift_insert ', err)
        }
        if (misfit) {
            var query_text = util.format("INSERT INTO unknownfeature " +
                "VALUES ('%s', '%s', '%s', '%s', '%s');", // fake node_config
                obs.node_id, obs.datetime, obs.node_config, obs.sensor, JSON.stringify(obs.data));
            rs_client.query(query_text, function(err) {
                if (err) {
                    log.error('error inserting data into unknownfeature table ', err)
                }
            });
            done();
        }
        else {
            var all_features = [];
            Object.keys(map[obs.sensor]).forEach(function(key) {
                var feature = map[obs.sensor][key].split('.')[0];
                if (all_features.indexOf(feature) < 0) {
                    all_features.push(feature)
                }
            });
            for (var j = 0; j < all_features.length; j++) {
                var feature = all_features[j];
                var query_text = util.format("INSERT INTO %s (node_id, datetime, node_config, sensor, ", feature.toLowerCase());
                var c = 0;
                Object.keys(map[obs.sensor]).forEach(function(key) {
                    if (map[obs.sensor][key].split('.')[0] == feature) {
                        if (c != 0) {
                            query_text += ', '
                        }
                        query_text += map[obs.sensor][key].split('.')[1];
                        c++;
                    }
                });
                query_text = util.format(query_text + ") " +
                    "VALUES ('%s', '%s', '%s', '%s'", obs.node_id, obs.datetime, obs.node_config, obs.sensor);
                Object.keys(map[obs.sensor]).forEach(function(key) {
                    if (map[obs.sensor][key].split('.')[0] == feature) {
                        query_text += ', ' + obs.data[key];
                    }
                });
                query_text += ');'; // fake node_config
                rs_client.query(query_text, function(err) {
                    if (err) {
                        log.error('error inserting data into ' + feature.toLowerCase() + ' table ', err)
                    }
                });
                done();
            }
        }
    });
}

/**
 * splits observation into formatted feature of interest output JSON
 *
 * @param {Object} obs = observation
 * in format:
 * { "node_id": "00A",
 *  "node_config": "011ab78",
 *  "datetime": "2016-08-05T00:00:08.246000",
 *  "sensor": "HTU21D",
 *  "data": { temperature: 37.90,
 *            humidity: 27.48 } }
 * @param {Object} map = sensor name to property array mapping as generated by update_map
 * @return {Array} array of formatted observation objects
 */
function format_obs(obs, map) {
    console.log('in format_obs');
    // features is simply an array of feature names matching the order of obs_list for easy key finding
    var obs_list = [];
    var features = [];
    var feature;
    var property;
    Object.keys(map[obs.sensor]).forEach(function(key) {
        feature = map[obs.sensor][key].split('.')[0];
        property = map[obs.sensor][key].split('.')[1];
        if (features.indexOf(feature) < 0) {
            obs_list.push({feature_of_interest: feature,
                node_id: obs.node_id,
                sensor: obs.sensor,
                datetime: obs.datetime,
                results: {}});
            features.push(feature)
        }
        obs_list[features.indexOf(feature)].results[property] = obs.data[key];
    });
    return obs_list
}

/**
 * determine if observation can be properly mapped
 *
 * @param {Object} obs
 * @param {Object} map
 * @return {Array} array of invalid keys
 */
function invalid_keys(obs, map) {
    log.info('in invalid_keys');
    var keys = [];
    Object.keys(obs.data).forEach(function (key) {
        if (!(key in map[obs.sensor])) {
            keys.push(key);
        }
    });
    log.info(keys);
    return keys
}

/**
 * sends message to apiary if sensor not already in blacklist
 *
 * @param {String} sensor = sensor name
 * @param {Array} blacklist = array of all sensor names whose metadata appears to be incorrect
 * @param {String} message_type
 * @param {Array} keys = invalid key names
 */
function send_error(sensor, blacklist, message_type, keys) {
    var message;
    if (message_type == 'does_not_exist') {
        message = 'Sensor ' + sensor + ' not found in sensor metadata. ' +
            'Please add this sensor.';
    }
    else if (message_type == 'invalid_key') {
        message = 'Received data from sensor ' + sensor + ' with unknown key(s) ' + keys + '. ' +
            'Please update the keys and properties in this sensors metadata.';
    }

    if (blacklist.indexOf(sensor) < 0) {
        request.post('http://' + process.env.PLENARIO_HOST + '/apiary/send_message',
            {
                json: {
                    name: sensor,
                    value: message
                }
            }, function (err, response, body) {
                log.info(body);
                if (err) {
                    log.error(err);
                }
            });
        blacklist.push(sensor)
    }
}

/**
 * sends message to apiary communicating that updating the map from postgres fixed the discrepancy,
 * i.e. that the sensor error message can be deleted from apiary
 *
 * @param {String} sensor = sensor name
 * @param {Array} blacklist = array of all sensor names whose metadata appears to be incorrect
 */
function send_correct(sensor, blacklist) {
    request.post('http://' + process.env.PLENARIO_HOST + '/apiary/send_message',
        {
            json: {
                name: sensor,
                value: 'resolve'
            }
        }, function (err, response, body) {
            log.info(body);
            if (err) {
                log.error(err);
            }
        });
    blacklist.splice(blacklist.indexOf(sensor), 1)
}

module.exports.update_map = update_map;
module.exports.parse_insert_emit = parse_insert_emit;
module.exports.format_obs = format_obs;
